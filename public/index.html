<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">Панель авторизации</title>
    <style>
        /* Стили остаются без изменений */
    </style>
</head>
<body>
    <div id="auth-page-container">
        <div id="auth-page-content">
            <h2 id="auth-title">Вход для администратора</h2>
            <form id="auth-form">
                <input type="text" id="username" placeholder="Имя пользователя (например, admin1)" required>
                <input type="password" id="password" placeholder="Пароль (например, adminXA)" required>
                <button type="submit" id="auth-submit">Войти</button>
                <div class="error-message" id="auth-error"></div>
            </form>
        </div>
    </div>

    <div id="error-page-container">
        <div id="error-page-content">
            <div class="error-code">502</div>
            <div class="error-message">
                <a href="#" class="link invisible-link" id="bad-gateway-link">Bad</a> Gateway
            </div>
            <div class="request-id">Request ID: 95fb249e39e5c6d9-PDX</div>
            <div class="info-text">Этот сервис в настоящее время недоступен. Пожалуйста, попробуйте снова через несколько минут.</div>
            <div class="info-text">Если вы являетесь владельцем сайта, обратитесь к <a href="https://render.com/docs" class="link">документации Render</a> для устранения неполадок.</div>
            <div class="powered-by">Powered by Render</div>
        </div>
    </div>

    <div id="main-app-container">
        <div id="main-app-content">
            <div class="header-container">
                <h1>Панель скриншотов</h1>
                <button id="clearAllScreenshots">Очистить все (с этой страницы)</button>
            </div>
            <div id="client-id-display">
                Ваш clientId: <span id="client-id-text"></span> (передайте этот ID помощнику)
            </div>
            <div id="helper-cards-container">
                <p class="no-helpers-message" id="no-helpers-message">Ожидание скриншотов от пользователей...</p>
            </div>
        </div>
    </div>

    <div id="full-screen-modal">
        <div id="modal-header">
            <button id="modal-close-button">Закрыть</button>
            <span id="screenshot-counter"></span>
        </div>
        <div id="modal-screenshots-container">
        </div>
    </div>

    <script>
        const authPageContainer = document.getElementById('auth-page-container');
        const errorPageContainer = document.getElementById('error-page-container');
        const mainAppContainer = document.getElementById('main-app-container');
        const authForm = document.getElementById('auth-form');
        const authTitle = document.getElementById('auth-title');
        const authSubmit = document.getElementById('auth-submit');
        const authError = document.getElementById('auth-error');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        const badGatewayLink = document.getElementById('bad-gateway-link');
        const pageTitle = document.getElementById('page-title');

        const helperCardsContainer = document.getElementById('helper-cards-container');
        let noHelpersMessage = document.getElementById('no-helpers-message');
        const clearAllScreenshotsButton = document.getElementById('clearAllScreenshots');

        const fullScreenModal = document.getElementById('full-screen-modal');
        const modalCloseButton = document.getElementById('modal-close-button');
        const modalScreenshotsContainer = document.getElementById('modal-screenshots-container');
        const screenshotCounter = document.getElementById('screenshot-counter');

        let ws;
        const frontendHelperData = new Map();
        let currentOpenHelperId = null;
        let authToken = localStorage.getItem('adminToken');
        const clientId = localStorage.getItem('clientId') || `client-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        localStorage.setItem('clientId', clientId);
        console.log('Frontend: Current clientId:', clientId);

        function showPage(pageName) {
            authPageContainer.style.display = 'none';
            errorPageContainer.style.display = 'none';
            mainAppContainer.style.display = 'none';
            fullScreenModal.style.display = 'none';

            if (pageName === 'auth') {
                authPageContainer.style.display = 'flex';
                document.body.style.backgroundColor = '#000';
                document.body.style.color = '#fff';
                pageTitle.textContent = 'Вход для администратора';
            } else if (pageName === 'error') {
                errorPageContainer.style.display = 'flex';
                document.body.style.backgroundColor = '#000';
                document.body.style.color = '#fff';
                pageTitle.textContent = '502 Bad Gateway';
            } else if (pageName === 'main_app') {
                mainAppContainer.style.display = 'block';
                document.body.style.backgroundColor = '#f0f2f5';
                document.body.style.color = '#333';
                pageTitle.textContent = 'Панель скриншотов';
                if (!ws || ws.readyState === WebSocket.CLOSED) {
                    initWebSocket();
                }
                checkNoHelpers();
            }
        }

        // Автоматическая проверка авторизации
        async function checkAuth() {
            if (authToken) {
                try {
                    const response = await fetch('/api/check-auth', {
                        method: 'GET',
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    const data = await response.json();
                    if (data.authenticated) {
                        showPage('main_app');
                        return true;
                    } else {
                        authToken = null;
                        localStorage.removeItem('adminToken');
                    }
                } catch (err) {
                    console.error('Frontend: Ошибка проверки авторизации:', err);
                }
            }
            showPage('auth');
            return false;
        }

        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            authError.textContent = '';
            const username = usernameInput.value.trim();
            const password = passwordInput.value.trim();

            if (!username || !password) {
                authError.textContent = 'Требуются имя пользователя и пароль';
                return;
            }

            try {
                const response = await fetch('/api/admin/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                const data = await response.json();

                if (response.ok) {
                    authToken = data.token;
                    localStorage.setItem('adminToken', authToken); // Сохраняем токен
                    showPage('main_app');
                } else {
                    authError.textContent = data.message || 'Ошибка входа. Проверьте имя пользователя и пароль.';
                }
            } catch (err) {
                authError.textContent = 'Ошибка сервера. Попробуйте позже.';
                console.error('Frontend: Ошибка авторизации:', err);
            }
        });

        badGatewayLink.addEventListener('click', (event) => {
            event.preventDefault();
            showPage('auth');
        });

        function initWebSocket() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${location.host}`;
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('Frontend: WebSocket подключен');
                ws.send(JSON.stringify({ type: 'frontend_connect', role: 'frontend', clientId }));
                ws.send(JSON.stringify({ type: 'request_initial_data', clientId }));
            };

            ws.onmessage = (event) => {
                let data;
                try {
                    data = JSON.parse(event.data);
                    console.log('Frontend: Получено сообщение:', data);
                } catch (err) {
                    console.error('Frontend: Ошибка разбора сообщения:', err);
                    return;
                }

                if (data.clientId && data.clientId !== clientId) {
                    console.log('Frontend: Игнорируем сообщение для другого clientId:', data.clientId);
                    return;
                }

                if (data.type === 'initial_data') {
                    data.data.forEach(item => {
                        frontendHelperData.set(item.helperId, {
                            hasAnswer: item.hasAnswer,
                            screenshots: []
                        });
                        addOrUpdateHelperCard(item.helperId, item.hasAnswer);
                    });
                    checkNoHelpers();
                } else if (data.type === 'screenshot_info') {
                    const { questionId, imageUrl, helperId, clientId: receivedClientId } = data;
                    console.log('Frontend: Обработка screenshot_info:', { questionId, imageUrl, helperId, clientId });
                    const filename = questionId.split('/').pop();
                    const index = filename.split('-').pop().replace('.png', '');

                    let helperInfo = frontendHelperData.get(helperId);
                    if (!helperInfo) {
                        helperInfo = { hasAnswer: false, screenshots: [] };
                        frontendHelperData.set(helperId, helperInfo);
                    } else {
                        helperInfo.hasAnswer = false;
                    }

                    const existingScreenshot = helperInfo.screenshots.find(s => s.questionId === questionId);
                    if (!existingScreenshot) {
                        helperInfo.screenshots.push({ questionId, imageUrl, answer: '', clientId });
                        helperInfo.screenshots.sort((a, b) => {
                            const timeA = parseInt(a.questionId.split('-')[1]) || 0;
                            const timeB = parseInt(b.questionId.split('-')[1]) || 0;
                            return timeB - timeA;
                        });
                    }

                    if (currentOpenHelperId === helperId) {
                        openFullScreenModal(helperId);
                    }

                    addOrUpdateHelperCard(helperId, helperInfo.hasAnswer);
                    checkNoHelpers();
                } else if (data.type === 'answer') {
                    const { questionId, answer, clientId: receivedClientId } = data;
                    for (const [helperId, helperInfo] of frontendHelperData.entries()) {
                        const screenshot = helperInfo.screenshots.find(s => s.questionId === questionId);
                        if (screenshot) {
                            screenshot.answer = answer;
                            helperInfo.hasAnswer = helperInfo.screenshots.every(s => s.answer && s.answer.trim() !== '');
                            addOrUpdateHelperCard(helperId, helperInfo.hasAnswer);
                            if (currentOpenHelperId === helperId) {
                                updateAnswerInModal(questionId, answer);
                            }
                            break;
                        }
                    }
                } else if (data.type === 'update_helper_card') {
                    const { helperId, hasAnswer } = data;
                    if (frontendHelperData.has(helperId)) {
                        const helperInfo = frontendHelperData.get(helperId);
                        helperInfo.hasAnswer = hasAnswer !== undefined ? hasAnswer : helperInfo.hasAnswer;
                        addOrUpdateHelperCard(helperId, helperInfo.hasAnswer);
                        if (currentOpenHelperId === helperId) {
                            openFullScreenModal(helperId); // Переоткрываем модал для обновления
                        }
                    }
                } else if (data.type === 'helper_deleted') {
                    const { helperId } = data;
                    deleteHelperCard(helperId);
                    frontendHelperData.delete(helperId);
                    checkNoHelpers();
                    if (currentOpenHelperId === helperId) {
                        closeFullScreenModal();
                    }
                } else if (data.type === 'screenshot_deleted_specific') {
                    const { questionId } = data;
                    let helperIdOfDeletedScreenshot = null;

                    for (const [hId, helperInfo] of frontendHelperData.entries()) {
                        const initialLength = helperInfo.screenshots.length;
                        helperInfo.screenshots = helperInfo.screenshots.filter(s => s.questionId !== questionId);
                        if (helperInfo.screenshots.length < initialLength) {
                            helperIdOfDeletedScreenshot = hId;
                            if (helperInfo.screenshots.length === 0) {
                                deleteHelperCard(hId);
                                frontendHelperData.delete(hId);
                            } else {
                                helperInfo.hasAnswer = helperInfo.screenshots.every(s => s.answer && s.answer.trim() !== '');
                                addOrUpdateHelperCard(hId, helperInfo.hasAnswer);
                            }
                            break;
                        }
                    }
                    checkNoHelpers();

                    if (currentOpenHelperId === helperIdOfDeletedScreenshot) {
                        const helperInfo = frontendHelperData.get(currentOpenHelperId);
                        if (helperInfo && helperInfo.screenshots.length > 0) {
                            openFullScreenModal(currentOpenHelperId);
                        } else {
                            closeFullScreenModal();
                        }
                    }
                } else if (data.type === 'screenshots_by_helperId') {
                    const { helperId, screenshots } = data;
                    const helperInfo = frontendHelperData.get(helperId);
                    if (helperInfo) {
                        helperInfo.screenshots = screenshots.filter(s => !s.clientId || s.clientId === clientId);
                        helperInfo.screenshots.sort((a, b) => {
                            const timeA = parseInt(a.questionId.split('-')[1]) || 0;
                            const timeB = parseInt(b.questionId.split('-')[1]) || 0;
                            return timeB - timeA;
                        });
                        openFullScreenModal(helperId);
                    }
                } else if (data.type === 'error') {
                    console.error('Frontend: Ошибка сервера:', data.message);
                    alert(data.message);
                }
            };

            ws.onclose = () => {
                console.log('Frontend: WebSocket отключен. Переподключение через 2 секунды...');
                setTimeout(initWebSocket, 2000);
            };

            ws.onerror = (error) => {
                console.error('Frontend: Ошибка WebSocket:', error);
                showPage('error');
            };
        }

        function addOrUpdateHelperCard(helperId, hasAnswer) {
            let card = document.querySelector(`.helper-card[data-helper-id="${helperId}"]`);
            if (!card) {
                card = document.createElement('div');
                card.className = 'helper-card';
                card.dataset.helperId = helperId;
                card.addEventListener('click', () => requestAndOpenHelperScreenshots(helperId));

                const h3 = document.createElement('h3');
                h3.textContent = `Пользователь: ${helperId}`;
                card.appendChild(h3);

                const statusDiv = document.createElement('div');
                statusDiv.className = 'status-indicator';
                card.appendChild(statusDiv);

                helperCardsContainer.prepend(card);
                if (noHelpersMessage) {
                    noHelpersMessage.style.display = 'none';
                }
            }
            const statusDiv = card.querySelector('.status-indicator');
            if (statusDiv) {
                statusDiv.textContent = hasAnswer ? 'Отвечено' : 'Ожидание ответа';
                statusDiv.className = `status-indicator ${hasAnswer ? 'answered' : 'pending'}`;
            }
        }

        function deleteHelperCard(helperId) {
            const card = document.querySelector(`.helper-card[data-helper-id="${helperId}"]`);
            if (card) {
                card.remove();
                checkNoHelpers();
            }
        }

        function checkNoHelpers() {
            const actualChildrenCount = helperCardsContainer.children.length;
            const hasOnlyMessage = actualChildrenCount === 1 && helperCardsContainer.children[0].id === 'no-helpers-message';

            if (actualChildrenCount === 0 || hasOnlyMessage) {
                if (!noHelpersMessage) {
                    noHelpersMessage = document.createElement('p');
                    noHelpersMessage.className = 'no-helpers-message';
                    noHelpersMessage.id = 'no-helpers-message';
                    helperCardsContainer.appendChild(noHelpersMessage);
                }
                noHelpersMessage.style.display = 'block';
                noHelpersMessage.textContent = 'Ожидание скриншотов от пользователей...';
            } else {
                if (noHelpersMessage) {
                    noHelpersMessage.style.display = 'none';
                }
            }
        }

        function requestAndOpenHelperScreenshots(helperId) {
            currentOpenHelperId = helperId;
            if (ws && ws.readyState === WebSocket.OPEN) {
                const helperInfo = frontendHelperData.get(helperId);
                if (helperInfo && helperInfo.screenshots.length > 0) {
                    openFullScreenModal(helperId);
                } else {
                    ws.send(JSON.stringify({
                        type: 'request_helper_screenshots',
                        helperId,
                        clientId
                    }));
                    console.log(`Frontend: Запрошены скриншоты для helperId: ${helperId}, clientId: ${clientId}`);
                }
            } else {
                console.error('Frontend: WebSocket не подключен. Невозможно запросить скриншоты.');
                showPage('error');
            }
        }

        function openFullScreenModal(helperId) {
            console.log('Frontend: openFullScreenModal вызван для helperId:', helperId, 'clientId:', clientId);
            const helperInfo = frontendHelperData.get(helperId);
            modalScreenshotsContainer.innerHTML = '';

            if (!helperInfo || helperInfo.screenshots.length === 0) {
                modalScreenshotsContainer.innerHTML = '<p class="no-screenshots-for-helper">Для этого пользователя пока нет скриншотов.</p>';
                screenshotCounter.textContent = '';
            } else {
                helperInfo.screenshots.forEach((ss, index) => {
                    if (ss.clientId && ss.clientId !== clientId) {
                        console.log('Frontend: Пропущен скриншот, clientId не совпадает:', ss.clientId);
                        return;
                    }
                    console.log('Frontend: Обрабатываем скриншот:', ss.questionId, 'URL:', ss.imageUrl);
                    const filename = ss.questionId.split('/').pop();
                    const parts = filename.split('-');
                    const screenshotNumber = parts[parts.length - 1].replace('.png', '');

                    const screenshotItem = document.createElement('div');
                    screenshotItem.className = 'screenshot-item';
                    screenshotItem.dataset.questionId = ss.questionId;

                    const h3 = document.createElement('h3');
                    h3.textContent = `Скриншот: ${screenshotNumber}`;
                    screenshotItem.appendChild(h3);

                    const imageWrapper = document.createElement('div');
                    imageWrapper.className = 'image-wrapper';
                    screenshotItem.appendChild(imageWrapper);

                    const img = document.createElement('img');
                    img.src = ss.imageUrl;
                    img.alt = `Скриншот ${ss.questionId}`;
                    img.onerror = () => console.error(`Frontend: Ошибка загрузки изображения: ${ss.imageUrl}`);
                    img.onload = () => console.log(`Frontend: Изображение загружено: ${ss.imageUrl}`);
                    imageWrapper.appendChild(img);

                    const answerDisplay = document.createElement('div');
                    answerDisplay.className = 'answer-display';
                    answerDisplay.textContent = ss.answer ? `Ответ: ${ss.answer}` : 'Ожидание ответа...';
                    screenshotItem.appendChild(answerDisplay);

                    const textarea = document.createElement('textarea');
                    textarea.placeholder = 'Введите ответ...';
                    textarea.value = ss.answer || '';
                    screenshotItem.appendChild(textarea);

                    const actionButtonsDiv = document.createElement('div');
                    actionButtonsDiv.className = 'action-buttons';
                    screenshotItem.appendChild(actionButtonsDiv);

                    const submitButton = document.createElement('button');
                    submitButton.textContent = 'Отправить ответ';
                    submitButton.className = 'submit-button';
                    submitButton.onclick = () => sendAnswer(ss.questionId, textarea.value, helperId);
                    actionButtonsDiv.appendChild(submitButton);

                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = 'Удалить';
                    deleteButton.className = 'delete-button';
                    deleteButton.onclick = () => deleteScreenshot(ss.questionId);
                    actionButtonsDiv.appendChild(deleteButton);

                    const resetButton = document.createElement('button');
                    resetButton.textContent = 'Сбросить ответ';
                    resetButton.className = 'reset-button';
                    resetButton.onclick = () => resetAnswer(ss.questionId, textarea, helperId);
                    actionButtonsDiv.appendChild(resetButton);

                    modalScreenshotsContainer.appendChild(screenshotItem);
                });

                screenshotCounter.textContent = `Скриншотов: ${helperInfo.screenshots.filter(ss => !ss.clientId || ss.clientId === clientId).length}`;
            }
            fullScreenModal.style.display = 'flex';
        }

        function closeFullScreenModal() {
            fullScreenModal.style.display = 'none';
            currentOpenHelperId = null;
            modalScreenshotsContainer.innerHTML = '';
        }

        modalCloseButton.addEventListener('click', closeFullScreenModal);

        function updateAnswerInModal(questionId, answer) {
            const screenshotItem = modalScreenshotsContainer.querySelector(`.screenshot-item[data-question-id="${questionId}"]`);
            if (screenshotItem) {
                const answerDisplay = screenshotItem.querySelector('.answer-display');
                if (answerDisplay) {
                    answerDisplay.textContent = `Ответ: ${answer || 'Нет ответа'}`;
                }
                const textarea = screenshotItem.querySelector('textarea');
                if (textarea) {
                    textarea.value = answer || '';
                }
            }
        }

        function sendAnswer(questionId, answer, helperId) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'submit_answer',
                    questionId,
                    answer,
                    clientId
                }));
                console.log(`Frontend: Отправлен ответ для ${questionId}: ${answer}, clientId: ${clientId}`);
            } else {
                console.error('Frontend: WebSocket не подключен. Невозможно отправить ответ.');
                showPage('error');
            }
        }

        function deleteScreenshot(questionId) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                if (confirm('Вы уверены, что хотите удалить этот скриншот? Это действие безвозвратно удалит его с сервера!')) {
                    ws.send(JSON.stringify({
                        type: 'delete_screenshot',
                        questionId,
                        clientId
                    }));
                    console.log(`Frontend: Отправлен запрос на удаление скриншота ${questionId}, clientId: ${clientId}`);
                }
            } else {
                console.error('Frontend: WebSocket не подключен. Невозможно отправить запрос на удаление.');
                showPage('error');
            }
        }

        function resetAnswer(questionId, textarea, helperId) {
            textarea.value = '';
            sendAnswer(questionId, '', helperId);
            console.log(`Frontend: Ответ для ${questionId} сброшен, clientId: ${clientId}`);
        }

        function clearAllDisplayedScreenshots() {
            helperCardsContainer.innerHTML = '<p class="no-helpers-message" id="no-helpers-message">Ожидание скриншотов от пользователей...</p>';
            frontendHelperData.clear();
            checkNoHelpers();
            alert('Отображение всех скриншотов очищено. Это не удаляет файлы с сервера. Для удаления с сервера перезапустите помощника (букмарклет), или удалите их вручную.');
        }

        clearAllScreenshotsButton.addEventListener('click', clearAllDisplayedScreenshots);

        // Периодический запрос keep-alive
        function startKeepAlive() {
            setInterval(() => {
                fetch('/keep-alive', { method: 'GET' })
                    .then(response => response.json())
                    .then(data => console.log('Frontend: Keep-alive success:', data.timestamp))
                    .catch(err => console.error('Frontend: Keep-alive failed:', err));
            }, 10 * 60 * 1000); // Каждые 10 минут
        }

        document.addEventListener('DOMContentLoaded', () => {
            checkAuth().then(() => {
                if (authToken) {
                    const clientIdText = document.getElementById('client-id-text');
                    if (clientIdText) clientIdText.textContent = clientId;
                    startKeepAlive(); // Запуск keep-alive после успешной авторизации
                }
            });
        });
    </script>
